- [WATCH] [object oriented programming]()
    - to start with, I'm going to use what we've learnt so far to write some code that might be useful for making games
    - define a function `initialise_player(name)`
        - `return {'name': name, 'experience': 0}`
    - define a function `play(player):`
        - `player['experience] += 1`
        - we need to pass in a reference to the particular instance of the player that we care about
    - this is what you would call functional programming, and might be the only way to implement things in other languages
    - however, there's a better way to do things: object oriented programming
        - it's a bit annoying to have to manually pass in the object im referring to
        - it would be cleaner if all functions relating to a particular type of object could be grouped together
    - so what is object oriented programming?
    - firstly, what does object oriented mean?
    - everything in our world can be considered as having its own attributes and functions
        - e.g. a car has attributes age, model, number plate (these are properties of it)
        - and it has functions like stop, start, change gear (these are things it can do)
    - python is an object oriented programming language
    - that means that everything in python is an object
        - like this string (define `my_string = 'hello'`)
        - we can access all of the strings attributes and functions using the dot operator
        - it has an attribute method lower()
        - we call object functions "methods", and we will probably use method and function interchangably
        - really methods are just callable attributes (attributes which are functions)
    - you can see all attributes and methods of an object using dir
        - show `dir(my_string)`
    - we can create our own objects
        - what is a class?
            - `class Player`
                - a class is a template for an object. its a blueprint which we can create instances from
        - define attributes outside of `__init__` for simplicity
            - `experience = 0`
        - create an instance
            - `my_player = Player()`
            - the parentheses after a class name "initialise" an instance of the blueprint
            - `print(my_player.experience)`
        - we can also define methods for any class
            - `def play():`
                `print('playing')`
        - create an instance & run the code
            - error: we've passed in too many arguments
            - looks like we've passes in 0 args as we specified
            - but in the background, python passes a variable in, in the first position
            - so when we define class methods, we need to add self as an arg
        - what is self?
            - its a reference to this particular instance of the class
        - its actually bad practice to define attributes out of a class method
            - python defines a special method named `__init__` which runs when you create an instance of a class (point to initialising instance in class)
            - we call this the initialiser or the constructor
            - `def __init__()`
            - it also takes in self
            - this is where you should write any code which needs to run to set up the class
            - it can take in arguments like `name`
            - which we know any car must have - it cant exist without them
            - this is where self first becomes useful
            - i might want to access some attributes of the instance in other functions
            - so i can assign them to attributes of self
                - `self.name = name`
                - `self.experience = 0`
            - the way you say these lines is "set this instance of the class's model attribute to model"
        - change play method to increment experience
            - `self.experience += 1`
    
    - docstrings
       - you can add what's called a docstring to functions, classes and methods of classes using triple quotes on the line after their definition
    - inheritance
        - a class that inherits from another gets access to all of it's attributes and methods
        - the child class overwrites any methods of the parent
    - why object oriented programming is useful
        - we can gather all variables and functions that relate to the same thing under an object
        -  but can make code much cleaner, more structured and easier to understand
    - having said that, it is not necessary
<!-- - [WATCH] [More OOP]() -->
- [CHALLENGE] create a class
    - create a car class
    - define the initialiser
        - it should take in two arguments (other than `self`), and assign these as attributes of the instance
            - one called model (e.g. Tesla), which has no default
            - one called year, which is an integer, which defaults to the current year (just hard code the current year in)
        - it should also define a new attribute
            - one called miles_driven, which is set to zero
    - create a method called drive
        - it should print('vroom') and increment the instance's miles_driven attribute by 1
    - create a method called info
        - it should then print the number of miles driven, the model name and the year
    - initialiase the class
    - call all of the methods
- magic methods
    - what's with the weird method name of the `__init__` function?
    - that method does not ever actually get called explicitly
        - that is, we never actually write `obj.__init__()`
    - instead, the `__init__` method is called implicitly
    - it defines the behaviour for some different syntax
    - in this case, the syntax it defines the behaviour for is parentheses after a class name. I.e. initialising an instance of a class
    - python recognises the names of many different "magic" methods
    - they are also known as "dunder" methods, for Double UNDERscore
- [CHALLENGE] create a class which uses some magic methods
    - create a class called Vector
    - define its initialiser which takes in a list of numbers
    - create an instance of the vector
    - use the `__repr__` method to define what is printed when we print the object
    - create another vector instance
    - define how you add two vectors together
    - define how you index an item in the vectore
    - (bonus) define how you measure whether it is greater than another vector (use Pythagoras theorem)
    - use the function you defined in the question above
- [DEMO] getting user input using the `input` function
- [CHALLENGE] create your own game of hangman (1 hr)
    - group size: 3
    - instructions
        - it's up to you how you implement it
        - you don't have to actually visualise the drawing of the man hanging :sweat_smile: 
        - start simple, with everything running cell by cell
        - group code which works together to perform a single task into a single function
        - when you have a simple working mvp, try and put your code into a `Hangman` class
        - I expect you to use
            - OOP
        - extra points for
            - using unpacking
            - using magic methods
- [WATCH] Error handling
# TODO add some realistic example to the live demo - it didnt make sense without a use case and was hard to answer questions around when to use
    - We may want to create code that is fault tolerant: it shouldnt crash the program if an error is encountered
    - we can do that in python using the try, except syntax
        - `try:`
            - `'a' - 'b'`
        - `except:`
            - `print('that failed')`
    - we can assign the error message as a variable in the exception
        - `except ValueError as e:`
    - we can also add a `finally` statement on the end of a try/except block to execute code regardless of whether the code
    - we can `raise` an exception
        - exceptions can be instances of the `Exception` class to raise an error with no specific type
        - otherwise we can raise 
        - use the name of the error
- [CHALLENGE] error handing
    - cause the following errors (don't handle them yet)
        - cause a NameError
        - cause a KeyError
        - cause a IndexError
        - EOFError
        - KeyBoardInterruptError
        - ValueError
    - handle each of the above error types
    - for each of them, print the error message when it occurs
    - add a `finally` block on the end and print something
    - now add some code to count how many errors occured and print that number in the finally block
    - find 3 other types of errors, cause them and catch them