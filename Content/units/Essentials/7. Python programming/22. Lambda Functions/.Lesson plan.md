- [WATCH] [Comprehensions]()
    - list comprehensions
        - list comprehensions are more compact ways to implement for that generate values
        - `list = []`
        - `for i in range(3):`
            - `list.append(i**2)`
        - compressed: `[i**2 for i in range(3)]`
        - a simple way to "map" an iterable into another iterable
    - conditionals within comprehensions
        - `big_numbers = [num for num in range(10) if num > 10]
        - we can also use else statements in comprehensions
            - `numbers = [num if num < 5 else 'some wild big number' for num in range(10)]`
    - dictionary comprehensions
        - `names = ['harry', 'christina']`
        - `name_lengths = {name: len(name) for name in names}`
        - `print(name_lengths)`
        - again we can also use conditionals in dict comprehensions
- [CHALLENGE] 
    - for each challenge switch person
    - use a list comprehension to capitalise every element in the list `['Hello', 'world']`
    - use a list comprehension to filter out every multiple of 5 from a range of numbers up to 100
    - use a dictionary comprehension to create a map between every integer up to 15 and it's value squared
        - now, use a dictionary comprehension to create a dictionary that does the inverse! (hint: iterate over squares.items(), where squares is the name of the dict you made in the above challenge)
    - create a list of dictionaries, each with a key called name, then use a list comprehension to map that list to the names themselves by indexing the dicts
    - use the os module to create a nested list comprehension to list every file in the my_lib directory
- [BREAK]
- [WATCH] [Generators]()
    - generators are like lists except they generate the items on the fly
    - this means that you dont need to store every item of the list in memory
    - they can be converted to a list using the python builtin `list()`
    - we can create generators by writing a function and replacing the return statment with a yield statement
        - create infinite_iterable generator
    - when generators hit a yield statement, they dont exit like a regular function, instead they stop, remembering their current position
    - generators look much like functions, except instead of the return keyword, you'll find a `yield`
    - when we call a generator however, it does not return us what we find after the yield
        - instead, it returns us an iterable
    - generator comprehensions
- [CHALLENGE] (10 mins) 
    - iterate through each of the following generators to test them
    - create generator and iterate through it to infinitely cycle through a list of items in order
        - cast it to a list to print it
    - create a generator that generates random numbers
    - create a generator that takes in two numbers and generates all multiples of 3 between the two of them
    - create a generator that generates the square of every number up to 100, if that number is even or is a multiple of 3
    - turn the above generator into a generator comprehension
    - create a generator that generates generators which each generate ranges up to a random number passed to them as an argument :o
        - create a double nested for loop
        - the outer loop should iterate through the outer generator
        - the inner loop should iterate through the range generated by the inner generator
- [WATCH] Decorators
    - let's say i wanted to be alerted every time a function stopped and started
    - a naive solution would be to manually put print statements before and after
    - a better solution would be to write a function what returns another function
        - `wrapped_function = get_wrapped_function(my_function)`
        - `wrapped_function()`
    - by doing this, we've "decorated" the function with some added functionality before and after it's called
    - we're going to turn our `get_wrapped_function` function, into what is known as a decorator, which provides a better syntax for decorating functions
    - using a decorator looks like this: we put @decorator_name on the line directly above a function definition
    - this wraps that function with some extra functionality
    - define a decorator - a function which takes in a function, and returns a wrapped function, commonly called wrapper
    - `def print_before_and_after(func):`
        - `def wrapper():`
- [DEMO] static and class methods
    - static methods
        - are methods of a class that can be called directly as an attribute of the class object, not from an instantiated instance of the class
        - we can overwrite self being passed in by using the @staticmethod decorator
    - class methods
        - are like static methods, but are passed in a reference to the class itself, much like self is passed into an instance method
        - we can overwrite self being passed in, and pass in a reference to the class by using the @classmethod decorator


- [CHALLENGE]
    - to start with, create a simple function which we will decorate that loops over the numbers 1 to 3 and prints them
    - create a decorator that prints "start" and "end" at the start and end of a function call
    - create a decorator to time how long a function takes to run and print the duration
    - change your function so that it takes in an argument, which is the upper bound of the range which it iterates to
    - create a decorator that takes in a word as an argument, and prints this word before running
    - now make it take in a second argument word, which it prints after running the decorated function
- [WATCH] Context managers
    - Context managers allow you to allocate and release resources precisely when you want to, most commonly using the `with` statement
    - show example of open and close manually
        - `f = open('myfile')`
        - `f.close()`
    - show use of context manager
- [WATCH] [Typing in Python]()
    - python is not a strongly typed language, meaning we dont have to specify variable types
    - but we can specify them if we want
    - following a definition, put a colon and a type
        - x: int = 10
    - note that this will not throw an error if its not adhered to, it's currently just for helping make code more useable
    - so if you see something like this you'll know what it means
    - you can also type function arguments and outputs
        - `def my_function(name: str, age: int, height: float) -> bool:`
- [CHALLENGE] 
    - create a function which takes in a list of words and returns the total number of characters in the list, then type the function's inputs and outputs
    - 
turn your code to capitalise every element in a list into a function, then type that function
- [CHALLENGE] convert your



- lambda functions